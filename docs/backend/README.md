# Backend GDE - FastAPI

## üìã Resumen General

El backend de GDE est√° construido con FastAPI y Python, dise√±ado para manejar procesamiento complejo, c√°lculos contables, procesamiento de archivos y operaciones que requieren mayor potencia de c√≥mputo. Se conecta a la base de datos PostgreSQL a trav√©s de Supabase.

## üèóÔ∏è Arquitectura

### Stack Tecnol√≥gico
- **Framework**: FastAPI
- **Lenguaje**: Python 3.11+
- **ORM**: SQLAlchemy 2.0 + asyncpg
- **Base de Datos**: PostgreSQL (Supabase)
- **Validaci√≥n**: Pydantic v2
- **Archivos**: python-multipart
- **Procesamiento**: pandas + openpyxl (CSV/Excel)
- **Im√°genes**: opencv-python + pyzbar
- **Notificaciones**: pywebpush
- **Autenticaci√≥n**: python-jose + bcrypt

## üìÅ Estructura de Carpetas

```
gde-backend/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ api/              # Endpoints REST
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ v1/          # Versi√≥n 1 de la API
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ products.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ guias.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pistoleo.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ costos.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ reports.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ files.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dependencies.py
‚îÇ   ‚îú‚îÄ‚îÄ models/          # SQLAlchemy models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ guia.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pistoleo.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ costo.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ audit.py
‚îÇ   ‚îú‚îÄ‚îÄ schemas/         # Pydantic schemas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ guia.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pistoleo.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ costo.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ common.py
‚îÇ   ‚îú‚îÄ‚îÄ services/        # L√≥gica de negocio
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ guia_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pistoleo_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ costo_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ report_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ file_service.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ notification_service.py
‚îÇ   ‚îú‚îÄ‚îÄ core/           # Configuraci√≥n
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ security.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ exceptions.py
‚îÇ   ‚îî‚îÄ‚îÄ main.py         # Punto de entrada
‚îú‚îÄ‚îÄ tests/              # Tests
‚îÇ   ‚îú‚îÄ‚îÄ unit/
‚îÇ   ‚îú‚îÄ‚îÄ integration/
‚îÇ   ‚îî‚îÄ‚îÄ fixtures/
‚îú‚îÄ‚îÄ scripts/            # Scripts de utilidad
‚îÇ   ‚îú‚îÄ‚îÄ init_db.py
‚îÇ   ‚îú‚îÄ‚îÄ seed_data.py
‚îÇ   ‚îî‚îÄ‚îÄ backup.py
‚îú‚îÄ‚îÄ requirements.txt    # Dependencias
‚îú‚îÄ‚îÄ Dockerfile         # Container
‚îî‚îÄ‚îÄ .env.example       # Variables de entorno
```

## üéØ Funcionalidades Principales

### 1. Procesamiento de Archivos
- Importaci√≥n de Excel/CSV
- Validaci√≥n de datos
- Procesamiento por lotes
- Logs de importaci√≥n

### 2. C√°lculos Contables
- Promedios ponderados
- C√°lculos de costos
- Reportes financieros
- An√°lisis de rentabilidad

### 3. Procesamiento de Im√°genes
- Detecci√≥n de c√≥digos QR/barras
- Procesamiento con OpenCV
- Optimizaci√≥n de im√°genes
- Extracci√≥n de metadatos

### 4. Generaci√≥n de Reportes
- Reportes financieros
- An√°lisis de inventario
- Reportes de gu√≠as
- Exportaci√≥n a PDF/Excel

### 5. Notificaciones
- Push notifications
- Email notifications
- Alertas de stock
- Notificaciones de sistema

### 6. Tareas Programadas
- Alertas de stock bajo
- Limpieza de logs
- Backups autom√°ticos
- Sincronizaci√≥n de datos

## üîÑ Flujos de Comunicaci√≥n

### Backend ‚Üí Supabase
- Operaciones complejas de BD
- Transacciones
- Procedimientos almacenados
- Agregaciones pesadas

### Backend ‚Üí Frontend
- Respuestas de API
- Archivos procesados
- Reportes generados
- Notificaciones

### Backend ‚Üí Servicios Externos
- APIs de terceros
- Servicios de notificaci√≥n
- Servicios de almacenamiento
- Integraciones contables

## üõ†Ô∏è Configuraci√≥n

### Variables de Entorno
```env
# Database
DATABASE_URL=postgresql://user:password@host:port/database
SUPABASE_URL=your_supabase_url
SUPABASE_KEY=your_supabase_key

# Security
SECRET_KEY=your_secret_key
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30

# External Services
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USERNAME=your_email
SMTP_PASSWORD=your_password

# File Storage
UPLOAD_DIR=uploads
MAX_FILE_SIZE=10485760  # 10MB

# Notifications
FCM_SERVER_KEY=your_fcm_key
WEBHOOK_URL=your_webhook_url
```

### Configuraci√≥n de Base de Datos
```python
# app/core/database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

DATABASE_URL = os.getenv("DATABASE_URL")

engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

## üöÄ Desarrollo

### Comandos Principales
```bash
# Instalaci√≥n
pip install -r requirements.txt

# Desarrollo
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000

# Tests
pytest

# Linting
black .
flake8 .

# Type checking
mypy .
```

### Scripts Disponibles
- `uvicorn app.main:app --reload`: Servidor de desarrollo
- `pytest`: Ejecutar tests
- `black .`: Formatear c√≥digo
- `flake8 .`: Linting
- `mypy .`: Verificaci√≥n de tipos

## üìä Modelos de Datos

### Base Model
```python
# app/models/base.py
from sqlalchemy import Column, Integer, DateTime
from sqlalchemy.ext.declarative import declarative_base
from datetime import datetime

class BaseModel:
    id = Column(Integer, primary_key=True, index=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
```

### Product Model
```python
# app/models/product.py
from sqlalchemy import Column, String, Integer, Decimal, Text, JSON
from .base import BaseModel

class Product(BaseModel):
    __tablename__ = "products"
    
    code = Column(String(50), unique=True, nullable=False, index=True)
    name = Column(String(200), nullable=False)
    description = Column(Text)
    category_id = Column(Integer, ForeignKey("categories.id"))
    stock_actual = Column(Integer, default=0)
    stock_minimo = Column(Integer, default=10)
    stock_maximo = Column(Integer)
    precio_compra = Column(Decimal(10, 2), default=0)
    precio_venta = Column(Decimal(10, 2), default=0)
    ubicacion_bodega = Column(String(100))
    proveedor = Column(String(100))
    codigo_barras = Column(String(100))
    imagenes = Column(JSON)
    metadata = Column(JSON)
```

## üîß Servicios

### Product Service
```python
# app/services/product_service.py
from typing import List, Optional
from sqlalchemy.orm import Session
from app.models.product import Product
from app.schemas.product import ProductCreate, ProductUpdate

class ProductService:
    def __init__(self, db: Session):
        self.db = db
    
    def create_product(self, product_data: ProductCreate) -> Product:
        product = Product(**product_data.dict())
        self.db.add(product)
        self.db.commit()
        self.db.refresh(product)
        return product
    
    def get_products(self, skip: int = 0, limit: int = 100) -> List[Product]:
        return self.db.query(Product).offset(skip).limit(limit).all()
    
    def get_product(self, product_id: int) -> Optional[Product]:
        return self.db.query(Product).filter(Product.id == product_id).first()
    
    def update_product(self, product_id: int, product_data: ProductUpdate) -> Optional[Product]:
        product = self.get_product(product_id)
        if product:
            for field, value in product_data.dict(exclude_unset=True).items():
                setattr(product, field, value)
            self.db.commit()
            self.db.refresh(product)
        return product
    
    def delete_product(self, product_id: int) -> bool:
        product = self.get_product(product_id)
        if product:
            self.db.delete(product)
            self.db.commit()
            return True
        return False
```

### File Service
```python
# app/services/file_service.py
import pandas as pd
from typing import List, Dict, Any
from app.models.import_log import ImportLog

class FileService:
    def __init__(self, db: Session):
        self.db = db
    
    def process_excel_file(self, file_path: str, entity_type: str) -> Dict[str, Any]:
        try:
            # Leer archivo Excel
            df = pd.read_excel(file_path)
            
            # Validar datos
            validated_data = self._validate_data(df, entity_type)
            
            # Procesar datos
            processed_data = self._process_data(validated_data, entity_type)
            
            # Crear log de importaci√≥n
            import_log = ImportLog(
                archivo=file_path,
                tipo_archivo='excel',
                entidad=entity_type,
                registros_totales=len(df),
                registros_exitosos=len(processed_data['success']),
                registros_fallidos=len(processed_data['errors']),
                errores=processed_data['errors']
            )
            self.db.add(import_log)
            self.db.commit()
            
            return processed_data
            
        except Exception as e:
            raise Exception(f"Error procesando archivo: {str(e)}")
    
    def _validate_data(self, df: pd.DataFrame, entity_type: str) -> pd.DataFrame:
        # Validaciones espec√≠ficas por tipo de entidad
        if entity_type == 'products':
            required_columns = ['code', 'name', 'stock_actual']
            missing_columns = [col for col in required_columns if col not in df.columns]
            if missing_columns:
                raise ValueError(f"Columnas faltantes: {missing_columns}")
        
        return df
    
    def _process_data(self, df: pd.DataFrame, entity_type: str) -> Dict[str, Any]:
        success = []
        errors = []
        
        for index, row in df.iterrows():
            try:
                # Procesar cada fila seg√∫n el tipo de entidad
                if entity_type == 'products':
                    processed_row = self._process_product_row(row)
                    success.append(processed_row)
                else:
                    raise ValueError(f"Tipo de entidad no soportado: {entity_type}")
                    
            except Exception as e:
                errors.append({
                    'row': index + 1,
                    'error': str(e),
                    'data': row.to_dict()
                })
        
        return {
            'success': success,
            'errors': errors
        }
```

## üîí Autenticaci√≥n y Seguridad

### JWT Authentication
```python
# app/core/security.py
from jose import JWTError, jwt
from passlib.context import CryptContext
from datetime import datetime, timedelta

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt
```

### Dependency Injection
```python
# app/api/dependencies.py
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from app.core.security import verify_token
from app.models.user import User

security = HTTPBearer()

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    try:
        payload = verify_token(credentials.credentials)
        user_id: str = payload.get("sub")
        if user_id is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    
    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise credentials_exception
    
    return user
```

## üìä Endpoints de la API

### Products API
```python
# app/api/v1/products.py
from fastapi import APIRouter, Depends, HTTPException
from app.services.product_service import ProductService
from app.schemas.product import Product, ProductCreate, ProductUpdate

router = APIRouter()

@router.get("/", response_model=List[Product])
async def get_products(
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db)
):
    service = ProductService(db)
    return service.get_products(skip=skip, limit=limit)

@router.post("/", response_model=Product)
async def create_product(
    product: ProductCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    service = ProductService(db)
    return service.create_product(product)

@router.get("/{product_id}", response_model=Product)
async def get_product(
    product_id: int,
    db: Session = Depends(get_db)
):
    service = ProductService(db)
    product = service.get_product(product_id)
    if not product:
        raise HTTPException(status_code=404, detail="Product not found")
    return product

@router.put("/{product_id}", response_model=Product)
async def update_product(
    product_id: int,
    product: ProductUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    service = ProductService(db)
    updated_product = service.update_product(product_id, product)
    if not updated_product:
        raise HTTPException(status_code=404, detail="Product not found")
    return updated_product

@router.delete("/{product_id}")
async def delete_product(
    product_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    service = ProductService(db)
    success = service.delete_product(product_id)
    if not success:
        raise HTTPException(status_code=404, detail="Product not found")
    return {"message": "Product deleted successfully"}
```

## üß™ Testing

### Unit Tests
```python
# tests/unit/test_product_service.py
import pytest
from app.services.product_service import ProductService
from app.schemas.product import ProductCreate

def test_create_product():
    # Arrange
    product_data = ProductCreate(
        code="TEST001",
        name="Test Product",
        stock_actual=100
    )
    
    # Act
    service = ProductService(db)
    product = service.create_product(product_data)
    
    # Assert
    assert product.code == "TEST001"
    assert product.name == "Test Product"
    assert product.stock_actual == 100
```

### Integration Tests
```python
# tests/integration/test_products_api.py
import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

def test_create_product():
    response = client.post(
        "/api/v1/products/",
        json={
            "code": "TEST001",
            "name": "Test Product",
            "stock_actual": 100
        }
    )
    assert response.status_code == 200
    assert response.json()["code"] == "TEST001"
```

## üöÄ Despliegue

### Docker
```dockerfile
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### Railway/Render
- Deploy autom√°tico desde Git
- Variables de entorno
- Health checks
- Logs autom√°ticos

## üìö Pr√≥ximos Pasos

1. Configurar proyecto FastAPI
2. Instalar dependencias
3. Configurar base de datos
4. Implementar modelos
5. Crear servicios
6. Implementar endpoints
7. Configurar autenticaci√≥n
8. Testing y optimizaci√≥n





